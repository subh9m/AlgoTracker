export const approachSteps = [
  { num: '01', title: 'UNDERSTAND & CLARIFY', desc: 'Ask targeted questions about input sizes, edge cases, constraints, and expected output format before writing code.' },
  { num: '02', title: 'BRUTE-FORCE FIRST', desc: 'Start with the simplest solution. Demonstrate understanding and create a baseline to optimize from.' },
  { num: '03', title: 'ANALYZE CONSTRAINTS', desc: 'Input size reveals required time complexity. Use this as your biggest hint for algorithm selection.' },
  { num: '04', title: 'OPTIMIZE & SELECT', desc: 'Look for memoization opportunities, hash map optimizations, two pointers, binary search, or greedy approaches.' },
  { num: '05', title: 'CODE & TEST', desc: 'Write clean code with meaningful names. Test normal cases, edge cases, and boundary conditions.' },
];

export const foundationalAlgos = [
  { title: 'HASH MAP', slug: 'hash-map', when: 'Need O(1) lookups, counting frequencies, or checking if elements exist. Perfect for problems requiring fast access to previously seen data.', keywords: 'count, frequency, unique, duplicate, seen before, complement, pair sum, anagram, group by', examples: 'Two Sum, Group Anagrams, Subarray Sum Equals K', code: `// Count frequency of elements\nunordered_map<int,int> freq;\nfor(int x : arr) freq[x]++;` },
  { title: 'BINARY SEARCH', slug: 'binary-search', when: 'Searching in sorted arrays or when finding specific value in sorted space. Also powerful for "search for the answer" problems with monotonic property.', keywords: 'sorted array, find target, logarithmic time, first/last occurrence, peak, minimum/maximum in range, rotated', examples: 'Search in Rotated Array, Find Peak Element, Sqrt(x)', code: `// Standard binary search\nint low = 0, high = n-1;\nwhile(low <= high){\n    int mid = low + (high-low)/2;\n    if(arr[mid] == target) return mid;\n    else if(arr[mid] < target) low = mid+1;\n    else high = mid-1;\n}` },
  { title: 'SLIDING WINDOW', slug: 'sliding-window', when: 'Problems involving contiguous subarrays/substrings with specific properties. Especially when you need min/max/optimal subarray.', keywords: 'subarray, substring, contiguous, window, maximum/minimum length, sum equals k, at most k, consecutive', examples: 'Longest Substring Without Repeating, Minimum Window Substring', code: `// Max sum subarray of size k\nint maxSum = 0, sum = 0;\nfor(int i=0;i<k;i++) sum += arr[i];\nmaxSum = sum;\nfor(int i=k;i<n;i++){\n    sum += arr[i] - arr[i-k];\n    maxSum = max(maxSum, sum);\n}` },
  { title: 'TWO POINTERS', slug: 'two-pointers', when: 'Problems on sorted arrays, finding pairs, or processing elements from both ends. Great for reducing O(n²) to O(n).', keywords: 'sorted array, pair, triplet, palindrome, opposite ends, meeting in middle, remove duplicates, in-place', examples: '3Sum, Container With Most Water, Valid Palindrome', code: `// Two sum in sorted array\nint left = 0, right = n-1;\nwhile(left < right){\n    int sum = arr[left] + arr[right];\n    if(sum == target) break;\n    else if(sum < target) left++;\n    else right--;\n}` },
  { title: 'BFS / DFS', slug: 'bfs-dfs', when: 'BFS for shortest paths in unweighted graphs and level-order traversal. DFS for exploring all paths and tree traversals.', keywords: 'shortest path, level-order, traverse, connected components, cycle detection, all paths, maximum depth', examples: 'Number of Islands, Level Order Traversal, Course Schedule', code: `// BFS traversal\nqueue<int> q;\nvector<bool> visited(n,false);\nq.push(start);\nvisited[start] = true;\nwhile(!q.empty()){\n    int node = q.front(); q.pop();\n    for(int nei : adj[node]){\n        if(!visited[nei]){\n            visited[nei] = true;\n            q.push(nei);\n        }\n    }\n}` },
  { title: 'BACKTRACKING', slug: 'backtracking', when: 'Finding all possible solutions, combinations, permutations. Make choices, recurse, then undo choices.', keywords: 'all combinations, all permutations, generate all, place queens, solve puzzle, word search, partition', examples: 'N-Queens, Generate Parentheses, Combination Sum', code: `// Generate all subsets\nvoid backtrack(vector<int>& nums, vector<int>& curr, int index, vector<vector<int>>& res){\n    res.push_back(curr);\n    for(int i=index;i<nums.size();i++){\n        curr.push_back(nums[i]);\n        backtrack(nums, curr, i+1, res);\n        curr.pop_back(); // undo choice\n    }\n}` },
  { title: 'RECURSION', slug: 'recursion', when: 'Solving a problem by breaking it into smaller, identical versions of itself. Essential for tree/graph traversals and many divide-and-conquer algorithms where the structure is self-similar.', keywords: 'base case, recursive call, subproblem, self-similar, tree traversal, divide and conquer, factorial, fibonacci', examples: 'Factorial, Fibonacci Sequence, Merge Sort, Tree Traversals (Inorder, Preorder, Postorder)', code: '// Factorial with Recursion\nint factorial(int n){\n    // Base Case: Stop condition\n    if (n <= 1) return 1;\n    // Recursive Step: Call itself\n    return n * factorial(n - 1);\n}' },
  { title: 'DYNAMIC PROGRAMMING', slug: 'dynamic-programming', when: 'Optimization problems with overlapping subproblems and optimal substructure. When brute force repeats calculations.', keywords: 'maximum/minimum, count ways, optimal, best, overlapping subproblems, subsequence, ways to, longest', examples: 'Coin Change, LCS, Edit Distance, House Robber', code: `// Fibonacci with DP\nvector<int> dp(n+1, -1);\nint fib(int n){\n    if(n<=1) return n;\n    if(dp[n] != -1) return dp[n];\n    return dp[n] = fib(n-1) + fib(n-2);\n}` },
  { title: 'HEAP / PRIORITY QUEUE', slug: 'heap-priority-queue', when: 'Need min/max element repeatedly or maintain sorted order while inserting/removing. Perfect for "top k" problems.', keywords: 'kth largest/smallest, top k, median, priority, merge sorted, closest, running median, k most frequent', examples: 'Kth Largest Element, Merge K Sorted Lists, Find Median, K Most Frequent Elements', code: `// Min Heap\npriority_queue<int, vector<int>, greater<int>> pq;\npq.push(5); pq.push(2); pq.push(10);\nint top = pq.top(); // 2\npq.pop();` },
  { title: 'MONOTONIC STACK / QUEUE', slug: 'monotonic-stack-queue', when: 'Finding next greater/smaller element or maintaining elements in increasing/decreasing order efficiently.', keywords: 'next greater, next smaller, previous greater, largest rectangle, trapping water, stock span', examples: 'Next Greater Element, Largest Rectangle in Histogram, Trapping Rain Water', code: `// Next Greater Element\nvector<int> nge(n, -1);\nstack<int> s;\nfor(int i=0; i<n; i++){\n    while(!s.empty() && arr[i] > arr[s.top()]){\n        nge[s.top()] = arr[i];\n        s.pop();\n    }\n    s.push(i);\n}` },
  { title: 'PREFIX SUM', slug: 'prefix-sum', when: 'Calculate range sums quickly or when subarray sums appear frequently. Preprocessing for O(1) queries.', keywords: 'range sum, subarray sum, sum between indices, continuous subarray, multiple queries', examples: 'Range Sum Query, Subarray Sum Equals K, 2D Prefix Sum', code: `// 1D Prefix Sum\nvector<int> prefix(n + 1, 0);\nfor(int i=0; i<n; i++)\n    prefix[i+1] = prefix[i] + arr[i];\nint sum = prefix[j+1] - prefix[i];` },
  { title: 'FLOYD’S CYCLE DETECTION', slug: 'floyds-cycle-detection', when: 'Detect cycles in linked lists or arrays when you can only traverse forward. Also used to find duplicates without extra space.', keywords: 'cycle detection, loop, linked list, duplicate number, slow and fast pointers', examples: 'Linked List Cycle, Find Duplicate Number', code: `ListNode* slow = head, *fast = head;\nwhile (fast && fast->next) {\n    slow = slow->next;\n    fast = fast->next->next;\n    if (slow == fast) return true;\n}\nreturn false;` },
  { title: 'KADANE’S ALGORITHM', slug: 'kadanes-algorithm', when: 'Find maximum (or minimum) sum of a contiguous subarray efficiently in O(n).', keywords: 'maximum subarray, contiguous, dynamic programming, prefix sum', examples: 'Maximum Subarray, Stock Buy and Sell', code: `int maxSum = arr[0], curr = arr[0];\nfor (int i=1; i<n; i++) {\n    curr = max(arr[i], curr + arr[i]);\n    maxSum = max(maxSum, curr);\n}` },
  { title: 'BINARY SEARCH ON ANSWER', slug: 'binary-search-on-answer', when: 'When minimizing or maximizing a feasible value that satisfies a condition (e.g., minimum largest subarray sum).', keywords: 'minimize maximum, maximize minimum, feasibility check, search space', examples: 'Split Array Largest Sum, Koko Eating Bananas', code: `int low=min_val, high=max_val;\nwhile (low < high) {\n    int mid = low + (high-low)/2;\n    if (check(mid)) high = mid;\n    else low = mid + 1;\n}\nreturn low;` },
  { title: 'BIT MANIPULATION', slug: 'bit-manipulation', when: 'Use binary operations for fast computations, subset generation, or optimization problems.', keywords: 'xor, subset mask, bit count, toggle, check bit, power of two', examples: 'Single Number, Count Bits, Subsets', code: `// Count number of set bits in an integer\nint count = 0;\nwhile (n) {\n    n &= (n - 1);\n    count++;\n}` },
  { title: 'TOP-K PATTERNS (HEAP)', slug: 'top-k-patterns', when: 'Find the k-th largest/smallest or top-k frequent elements efficiently using heaps or bucket sort.', keywords: 'top k, kth largest, frequency, heap, priority queue, bucket sort', examples: 'Top K Frequent Elements, Kth Largest Element', code: `priority_queue<pair<int,int>, ..., greater<>> pq;\nfor (auto &[num, freq] : freqMap) {\n    pq.push({freq, num});\n    if (pq.size() > k) pq.pop();\n}` },
  { title: 'TRIE (PREFIX TREE)', slug: 'trie-prefix-tree', when: 'String prefix matching, autocomplete systems, or efficient storage of words sharing common prefixes.', keywords: 'prefix, autocomplete, word search, dictionary, common prefix', examples: 'Implement Trie, Word Search II', code: `struct TrieNode {\n    bool end = false;\n    TrieNode* child[26] = {nullptr};\n};\n// ... see full implementation` },
  { title: 'GREEDY ALGORITHMS', slug: 'greedy-algorithms', when: 'For problems where making the locally optimal choice at each step gives a global optimum.', keywords: 'optimal, greedy choice, scheduling, interval, minimum, maximum', examples: 'Jump Game, Gas Station, Activity Selection', code: `// Activity Selection\nsort(act.begin(), act.end(), ...);\nint count = 0, end_time = 0;\nfor (auto [s, e] : act) {\n    if (s >= end_time) {\n      count++;\n      end_time = e;\n    }\n}` },
];

export const advancedAlgos = [
    { title: "UNION-FIND (DSU)", slug: "union-find-dsu", when: "Efficiently manage groups of connected components. Used in Kruskal’s MST and connectivity queries.", keywords: "union by rank, path compression, disjoint set, connectivity", examples: "Kruskal’s Algorithm, Redundant Connection", code: "int find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\nvoid unite(int x, int y) { ... }" },
    { title: "KRUSKAL’S MST", slug: "kruskals-mst", when: "Find the minimum total edge weight connecting all nodes in a weighted undirected graph.", keywords: "MST, minimum cost, undirected graph, edges, connectivity", examples: "Connecting Cities, Minimum Network Cost", code: "sort(edges.begin(), edges.end());\nint total = 0;\nfor (auto &e : edges) {\n    if (find(e.u) != find(e.v)) {\n        unite(e.u, e.v);\n        total += e.w;\n    }\n}" },
    { title: "SEGMENT TREE", slug: "segment-tree", when: "Efficiently perform range queries and updates on arrays (e.g., sum or min queries).", keywords: "range sum, range query, update, interval tree", examples: "Range Sum Query - Mutable", code: "void build(...) { ... }\nint query(...) { ... }\nvoid update(...) { ... }" },
    { title: "TOPOLOGICAL SORT", slug: "topological-sort", when: "Order tasks or nodes with dependencies (DAG only). Useful for scheduling or dependency resolution.", keywords: "dependencies, prerequisites, DAG, ordering, course schedule", examples: "Course Schedule I & II, Alien Dictionary", code: "// Kahn's Algorithm (BFS)\nvector<int> indeg(n, 0); ...\nqueue<int> q; ...\nwhile (!q.empty()) { ... }" },
    { title: "DIJKSTRA'S ALGORITHM", slug: "dijkstras-algorithm", when: "Find shortest paths from a single source in weighted graphs with non-negative edges.", keywords: "shortest path, weighted graph, distance, routing, minimum cost", examples: "Network Delay Time, Cheapest Flights Within K Stops", code: "vector<int> dist(n, INT_MAX);\npriority_queue<pair<int,int>, ...> pq;\ndist[src] = 0; pq.push({0, src});\nwhile (!pq.empty()) { ... }" },
    { title: "KMP (STRING MATCHING)", slug: "kmp-string-matching", when: "Efficient substring search in large strings. Avoids re-scanning previously matched characters.", keywords: "substring search, pattern matching, LPS array, string search", examples: "Pattern Search, Repeated Substring Pattern", code: "vector<int> buildLPS(string p) { ... }\nbool kmpSearch(string s, string p) { ... }" },
    { title: "FENWICK TREE (BIT)", slug: "fenwick-tree-bit", when: "Efficient prefix/range sum queries and updates in O(log n). Simpler than Segment Tree for sums.", keywords: "range sum, prefix sum, update, binary indexed tree", examples: "Range Sum Query, Inversion Count", code: "void update(int i, int val) {\n    for (; i<=n; i += i&-i) bit[i] += val;\n}\nint query(int i) {\n    int sum = 0;\n    for (; i>0; i -= i&-i) sum += bit[i];\n    return sum;\n}" },
    { title: "RABIN-KARP", slug: "rabin-karp", when: "Multiple pattern search using rolling hash. Ideal for substring search in large text.", keywords: "rolling hash, substring search, pattern matching", examples: "Search substring, Plagiarism detection", code: "const int BASE = 256, MOD = 1e9+7;\nlong long ph=0, th=0, h=1;\n// ... hash calculation and comparison" },
    { title: "FLOYD-WARSHALL", slug: "floyd-warshall", when: "Compute shortest paths between all pairs of vertices. Works with negative edges but no negative cycles.", keywords: "all-pairs shortest path, DP on graphs, adjacency matrix", examples: "Shortest distances between cities", code: "for (int k=0;k<n;k++)\n    for (int i=0;i<n;i++)\n        for (int j=0;j<n;j++)\n            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);" },
    { title: "BELLMAN-FORD", slug: "bellman-ford", when: "Find shortest paths from a single source in graphs with negative edge weights. Detects negative cycles.", keywords: "shortest path, negative weights, relax edges, negative cycle", examples: "Currency Arbitrage, Shortest Path with Negative Edges", code: "vector<int> dist(n, INT_MAX); \ndist[src]=0;\nfor(int i=0;i<n-1;i++)\n  for(auto &e : edges)\n    dist[e.v] = min(dist[e.v], dist[e.u]+e.w);\n// check for negative cycle" },
    { title: "HEAVY-LIGHT DECOMPOSITION", slug: "heavy-light-decomposition", when: "Efficiently answer path or subtree queries on trees (e.g., sum, max) with log(n) complexity.", keywords: "tree queries, path query, subtree query, segment tree", examples: "Max/Min on Path, Sum of Subtree", code: "void dfs_sz(int u,int p){ ... }\nvoid dfs_hld(int u,int p,int h){ ... }\n// combined with segment tree" },
];

export const timelineData = [
    { week: 'WEEK 1-2', title: 'Foundation Building', desc: 'Master Hash Maps, Two Pointers, and Sliding Window. Practice 3-5 easy problems daily. Focus on understanding patterns over speed.'},
    { week: 'WEEK 3-4', title: 'Core Algorithms', desc: 'Master BFS, DFS, Binary Search, and Basic DP. Practice 2-3 medium problems daily. Focus on recognizing when to use each algorithm.' },
    { week: 'WEEK 5-6', title: 'Advanced Patterns & Problem Types', desc: 'Tackle Tries, DSU, Segment Trees, Monotonic structures, and advanced DP. Solve 1-2 hard problems every other day. Build short notes for pattern recognition.' },
    { week: 'WEEK 7', title: 'Mock Interviews & Timed Practice', desc: 'Simulate interview conditions: 45–60 minute mock interviews, pair-programming or whiteboard style. Analyse mistakes, write clean solutions and discuss trade-offs.' },
    { week: 'WEEK 8', title: 'Refinement & Final Prep', desc: 'Polish weak areas, revisit tricky problems, build a cheat-sheet of algorithms and edge cases. Do 2 full mock interviews and 3 timed contests to finish strong.' },
    { week: 'GRADUATION', title: 'Go Live', desc: 'Apply consistently. Use your notes during interviews, reflect after each session, and iterate on feedback. Confidence and clarity beat rushing—you got this.' },
];

export const quotesData = {
  set1: {
    duration: 8000,
    quotes: [ { "text": "Whatever your current ability, effort is what ignites that ability and turns it into accomplishment.", "author": "— CAROL DWECK" }, { "text": "Discipline is the bridge between goals and accomplishment.", "author": "— JIM ROHN" }, { "text": "Dream big. Work hard. Stay humble.", "author": "— UNKNOWN" }, { "text": "Don’t let what you cannot do interfere with what you can do.", "author": "— JOHN WOODEN" }, { "text": "Success doesn’t come from what you do occasionally, it comes from what you do consistently.", "author": "— MARIE FORLEO" }, { "text": "First, solve the problem. Then, write the code.", "author": "— JOHN JOHNSON" }, { "text": "You don’t have to be perfect, just consistent.", "author": "— UNKNOWN" }, { "text": "The secret of getting ahead is getting started.", "author": "— MARK TWAIN" }, { "text": "Push yourself because no one else is going to do it for you.", "author": "— UNKNOWN" }, { "text": "The harder you work for something, the greater you’ll feel when you achieve it.", "author": "— UNKNOWN" }, { "text": "Learning never exhausts the mind.", "author": "— LEONARDO DA VINCI" }, { "text": "Code is like humor. When you have to explain it, it’s bad.", "author": "— CORY HOUSE" }, { "text": "The only way to learn a new programming language is by writing programs in it.", "author": "— DENNIS RITCHIE" } ]
  },
  set2: {
    duration: 9000,
    quotes: [ { "text": "Success is not final, failure is not fatal: it is the courage to continue that counts.", "author": "— WINSTON CHURCHILL" }, { "text": "Mistakes are proof that you are trying.", "author": "— JENNIFER LIM" }, { "text": "Keep coding even when it feels hard — that’s when you learn the most.", "author": "— UNKNOWN" }, { "text": "Failure is simply the opportunity to begin again, this time more intelligently.", "author": "— HENRY FORD" }, { "text": "You don’t have to be great to start, but you have to start to be great.", "author": "— ZIG ZIGLAR" } ]
  },
  set3: {
    duration: 9000,
    quotes: [ { "text": "The expert in anything was once a beginner.", "author": "— HELEN HAYES" }, { "text": "Data structures are the building blocks of efficient thinking.", "author": "— UNKNOWN" }, { "text": "Practice like you’ve never won, perform like you’ve never lost.", "author": "— BERNARD F. ASUNCION" }, { "text": "Every great coder you know started with a single print statement.", "author": "— UNKNOWN" }, { "text": "It’s not about memorizing algorithms; it’s about understanding problems.", "author": "— GAYLE LAAKMANN MCDOWELL" } ]
  },
  set4: {
    duration: 9000,
    quotes: [ { "text": "The best way to predict the future is to create it.", "author": "— PETER DRUCKER" }, { "text": "Don’t watch the clock; do what it does. Keep going.", "author": "— SAM LEVENSON" }, { "text": "Focus on being productive instead of busy.", "author": "— TIM FERRISS" }, { "text": "The only way to do great work is to love what you do.", "author": "— STEVE JOBS" }, { "text": "It does not matter how slowly you go as long as you do not stop.", "author": "— CONFUCIUS" }, { "text": "Believe you can and you’re halfway there.", "author": "— THEODORE ROOSEVELT" } ]
  }
};